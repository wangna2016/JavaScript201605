<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>事件委托/事件代理</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            background: #ccc;
            overflow: hidden;
        }

        .outer {
            margin: 20px auto;
            padding: 50px;
            width: 100px;
            height: 100px;
            background: green;
            cursor: pointer;
        }

        .outer .inner {
            width: 100px;
            height: 100px;
            background: red;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="outer" id="outer">
    <div class="inner" id="inner">

    </div>
</div>

<script type="text/javascript">
    var outer = document.getElementById("outer"),
            inner = document.getElementById("inner");

    document.body.onclick = function (ev) {
        ev = ev || window.event;
        var tar = ev.target || ev.srcElement;//->获取到事件源

        if (tar.id === "inner") {
            console.log("inner");
            return;
        }

        if (tar.id === "outer") {
            console.log("outer");
            return;
        }

        console.log("body");
    };

    //->事件委托:利用事件冒泡传播的机制,如果一个容器中很多的元素都需要在某个行为触发的时候执行一些操作,这样的话,我们只需要给最外层容器的相关行为绑定一个方法,这样的话不管触发里面哪一个元素的相关行为,都会传播到最外层元素上,我们在最外层元素绑定方法执行的时候,通过判断触发的事件源来实现不同的操作

    //->使用事件委托进行处理会比平时一个个元素绑定方法性能提高将近一倍
</script>
</body>
</html>