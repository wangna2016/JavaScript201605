<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>作用域链和内存释放问题</title>
</head>
<body>
    <div id="div1"></div>
</body>
</html>
<script>
    /*
    * 堆内存的释放
    *
    * */
    var obj1 = {haha:4}; //这个obj它是一个堆内存地址，ojb存储的是这个对象地址的引用
    var obj2 = obj1; //把ojb的地址赋值给ojb2一份,ojb2和ojb1同时共享一个内存地址
    //如果想让这个对象的堆内存释放，那么就让这个堆内存没有任何变量引用就行
    obj1 = obj2 = null; //这样就obj1和obj2都不在引用这个对内存地址，那么浏览器就会合适的时间自己主动去释放掉这个堆内存地址

    /*
    *   栈内存产生和释放： 代码运行的时候就会形成一个作用域，而这个作用域就是一个栈内存。刚刚打开的浏览器就会产生一个全局的window作用域(这是顶级作用域，只有关闭网页的时候才会释放)，换句话说，释放掉的内存里存的任何变量都会丢失，如果不释放这个栈内存里存储的任何变量都会原封不动的保留,运行函数的时候会执行函数体内的代码，也给函数提供运行环境，所以也会产生一个作用域
    *   不释放： 函数在运行结束后，如果函数内部的某一个部分(一般是一个对象数据类型)，被函数外部占用那么这个函数运行时产生的私有作用域就不会被释放
    *       1 函数运行的时候，函数体内return后面的引用数据类型被函数外面的变量接收，那么这个函数运行时候产生的那个栈内存(私有作用域和私有变量)不会释放
    *       2 函数运行的时候，函数体内如果是一个匿名函数赋值给元素的事件属性，其实也就是在函数内部做的事件绑定，那么由于绑定的这个匿名函数被元素的事件属性占用，所以这个函数运行时候产生的栈内存也不会被释放
    *       3 不立即释放: 函数执行的时候return后面的函数又立刻执行属于不立即释放。
    *
    * */
    //for(var i=0; i<lleng; i++)  3
    var oDiv = document.getElementById('div1');
     //3
        (function (k){ //自运行函数运行时候产生的栈内存作用域会被释放么？
            var i = 0
            //var x = 100; //这个变量也不会被释放吧
           /* olis[0].onclick = function (){ //事件绑定
                change(i);
            }*/
        })(0);


      /*  olis[i].index = i;
        olis[i].onclick = function (){
            change(this.index);
        }*/




    function fn(){
       return function (){ //这是一个引用数据类类型的
           console.log(1)
       }
    }
    //fn(); //这会也即使你返回了，但是没有人占用。在函数外部被占用
    var res = fn(); //如果这个返回值(对象数据类型)被一个外部变量接收，那么就符合内存不释放的条件,把返回的这个函数所代表的堆内存地址赋值给res。res一直都占用着这个地址。
    //res = null;


    function foo(){
        return function (){
            //console.log(123);
        }
    }
    foo()();








    var num = 12;
    function fn(){
        //var num = 120; //由于fn运行时候的作用域没有被释放，所以这个num也没有被释放
        return function (){ //return的是一个函数，是引用数据类型。并且赋值给f变量。被占用了是不是fn的运行时候的栈内存没有被释放
            //console.log(num);
        }
    }
    var f = fn(); //fn这个函数的执行结果==>里面的return
    f(); //return后面的函数运行，当前作用域没有num变量  120


    /*
    *  作用域链：函数在执行的时候，如果当前作用域没有这个变量，那么就去上一级作用域，如果上一级作用域也没有就是一直向上查找，一直到顶级作用域window。如果还没有报错，我们把这种查找机制叫做作用域链
    *  ps: 上一级作用域是谁只跟函数在哪里定义的有关系 比如： 刚刚的f()就是在全局执行的。但是上一级作用域确实fn()运行的栈内存
    * */

    function fnn(){
        var i=2;
        return function (n){
            //var n=10;
            console.log(n+(i++)); //10 + i++
        }
    }
    var f = fnn(); //把fnn运行结束后的结果赋值f，符合函数运行产生的作用域不释放，由于没释放所以i=2也保留下来了
    f(10); //就是返回的那个函数运行，n传了10参数,打印10+ i++ 由于先运算后累加i，i在当前作用域没有，通过作用域链去上一级作用域查找。由于上一级作用域的i没有被释放。12，但是打印之后i的累加运算还要进行。所以把上一级作用域里的i变成了3
    f(20); //23  由于上一次运算所有的东西都保留下来，包括累加之后的i也变成了3，所以这一次需要在i=3的基础上去累加
    //f(20); f(20); f(20) 只要小f一次那个i就会被累加一次
    fnn()(10); //属于不立即释放。只要执行结束之后所有的东西都被释放了。那么i在下一次执行的时候又恢复原始的值了
    fnn()(20); //由于上一次被释放了，i没有被保存下来。所以这一次i还是每次函数运行的时候自己的私有变量i=2

    //这样的问题其实关注的重点是这个返回的函数是否被变量接受了，如果保存了那么就没有释放。以后都是累加
    // 如果没保存就释放了。以后运算都是恢复原始状态。因为每个作用域之间都是私有的不会互相影响

    // 12 23 12 22
    // 12 23 12 22
    // 12 23 12 22



    /*
    *  i++ 和 ++i 的区别
    *    i++是运算后累加，累加是向i自己身上累加.
    *    ++i是先累加后运算
    *
    * */
   // var i=0; //1 2  3 4
   /* i++;
    ++i;
    console.log(i);*/
    /*console.log( 2 + i++); //先运算先打印2+0，然后再把i从0累加到1
    console.log(i);
    console.log(2+ ++i); //3 先让i自身累加1，然后再和2相加*/

    //console.log(2 +  i/*2*/++  +  ++i /*4*/ +  i++ /*6*/  +  ++i /*10*/);
    //console.log(i); //??  4
</script>