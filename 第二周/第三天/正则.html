<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>fuck</title>
</head>
<body>

</body>
</html>
<script>
    /*
     *    正则表达式:  引用数据类型  正则的作用： 1 用来匹配字符串  2 用来来捕获字符串
     *                其实也就是验证字符串是否符合我编写的规则
     *    如何创建一个正则：字面量方式 和 实例创建方式
     *
     *
     * */
    //创建一个正则
    var reg = /a/; //用两个/包起来一个或者多个元字符就是正则 字面量的创建方式
    var reg = new RegExp(); //这是用实例的方式创建一个正则,但是有参数和没有参数是有区别的

    var reg1 = /b/; //规则是斜杠里面的部分,只要字符串中包含一个b就符合规则
    var str1 = '9909090909b';
    /*
     *  正则的常用方法：1 test 用来验证字符串是否符合规则  ==>  返回值只有true和false
     *                 2 exec  用正则来捕获符合规则的字符串 ==> 返回值一定是捕获回来的
     * */
    //console.dir(reg1);
    //console.log(reg1.test(str1)); //用正则去验证字符串是否符合规则  ==> true
    /*
    *   正则特点：
    *       1 ^和$分别是描述以什么开始和以什么结束，但是：它们都不占位置
    *
    *
    *
    * */

    var reg2 = /^b$/; //^是以什么什么开始  $以什么什么结束,其实这个正则只有'b'符合规则
    var str2 = '888b999';
    str2 = 'b'; //这里注意下'bbb'是不符合规则的。
    console.log(reg2.test(str2)); //这还符合规则么？ false

    /*
    *   正则中常用来特殊意义的元字符：
    *       \d  0-9的任意数组
    *       \D  除了\d
    *       \w  字母数字下划线  [a-z][A-Z]_
    *       \n  匹配换行符
    *       \b  匹配边界 ==> 字符串开始和结束的地方肯定是一个边界 空格|多个空格|Tab制表符都可以理解为边界
    *       \s 匹配空格 空白  等任意空的字符
    *       . 在正则表达式中不是小数点了,除了\n之外的任意字符
    *       \ 在正则中 \代表的是转义。把\后面的具有特殊意义的字符转义成本身
    *
    *
    * */
    var reg3 = /d/; //是不是只要字符串中包含一个d就可以  /^d$/这样就只有字符串d才可以
    reg3 = /\d/; //  \d再也不是\d了。代表任意一个从0-9的数字,没有^$那么只要字符串中包含一个\d其实也就是任意一个0-9的数字就成立
    reg3 = /^\d\d$/; //这里需要两个数字满足条件
    var str3 = 'aaabbb90ccc';
    console.log(reg3.test(str3));

    var reg4 = /\w\d\w/; //
    var str4 = '123';
    str4 = "%%%%%%%_0_";
    console.log(reg4.test(str4));

    //
    var reg5 = /\b\w\b \d\b/;
    var str5 = '_ 7';
    console.log(reg5.test(str5));

    var reg6 = /\b\w\d\s\d/; //由于这个\s只能匹配一个空格，那么我们需要量词符
    var str6 = 'w6 5';
    console.log(reg6.test(str6));

    /*
    *   正则表达式中常用的量词：一般出现在元字符后面用来修饰这个元字符出现的次数
    *       * 代表0个到多个 ==> 可以不出现或者1到多次
    *       + 1个到多个   ==> 至少出现一次
    *       ? 0次或者1次  ==> 最多出现一次
    *       {n} 出现n次
    *       {n,} 出现n到多次 ==> 至少出现n次
    *       {n,m}  出现n到m次
    *
    * */
    var reg7 = /\d*/; //\d可以出现0次到多次
    reg7 = /^\d+$/; //\d至少出现一次
    reg7 = /^\d?$/; //\d可以出现0次或者一次
    var str7 = "1324123412341234123412341234";
    str7 = 'zhufen9g'; //
    console.log(reg7.test(str7));


    var reg8 = /\./; //正则里的这个\就是把.还原成自己本身的意思
    var str8 = ".";
    console.log(reg8.test(str8));


    //写一个简单的验证手机号的正则？   以1开头后面紧跟10个数组
    var reg = /^1\d{10}$/;

    //非空验证??(只要不是空我就认为通过)  先去匹配任意空
    var reg = /^\s*$/;  //这个正则表达式可以验证空格或者空字符串或者多个空空格，开始^和结束$必须要添加上
    !reg.test('需要验证字符串是否是空');

    //学过一个叫做替换字符串的方法？ replace(old,new);
    var str = ' c1 '; //像引用多个class类,怎么做到把c1前面的空格和c3后面的空格替换掉
    //把这个字符串的前后空格替换掉
    str = str.replace(/ /g,''); //其实就是把空格字符串用空字符串替换,加上了这个g之后就是全文匹配
    console.log(str);
    /*
    *   replace(old,new) 用法：
    *       1 old这个参数可以是一个正则，把这个正则所匹配来的字符串用new替换
    *       2 new这个参数可以是一个匿名函数，这个匿名函数的返回值替换old所匹配到的字符
    * */
    var str = 'zhufeng2015peixun2016'; //\d+ 0-9数出现1次到多次
    str = str.replace(/\d+/g,function (){ //第二个参数是一个匿名函数，这个匿名函数的返回值是我return后面的字符串，用这个匿名函数的返回值匹配正则所匹配到的字符串
       return '田喜';
    });
    console.log(str);
    /*
    *   正则中的修饰符：常用的就只有3个    img
    *       g: 全文匹配  global
    *       i: 忽略大小写  ignoreCase
    *       m: 多行匹配    multiLine
    *
    * */

    /*
    *   正则的懒惰性和贪婪性:
    *       懒惰性：尽可能少的去匹配次数   'zhufeng2015peixun2016'; /\d+/g 如果没有这个g那么就只能把2015匹配到
    *       贪婪性：每次尽可能多的去匹配   \d+ 1次或多次  但是却把多次匹配回来了
    *
    * */

    //写一个去掉首尾空格的正则  思路：把首位空格匹配到

    var testStr = "     c1     c2 c3     ";
    var reg = /^ +| +$/g; //x|y  以至少一个空格开头 或者 以至少一个空格结尾,这个正则就是常用的去掉字符串的首尾无效空格的
    testStr = testStr.replace(reg,function (){
        return '&'
    }); //如果第二个参数是一个匿名函数，是用匿名函数的返回值来替换reg匹配到的结果

    /*
    *   正则表达式中或者操作: 在正则表达式中的后者是 |,如果出现或者运算一般我们用小括号包含一下。这样能改变优先级问题
    *       x|y   x或者y
    *       [xyz]  也是x或者y后者z
    *       [a-z]   在中括号中的"-"前后都有字符代表的是从a到z中的任意字符
    *       [0-9]  \d
    *       [^xyz]  ^符号如果出现在[]中，是非的意思  除了xyz
    *       ps: 把'.'放到[]中就代表'.'自己本身了,但是\d \w这样的需要转义才会代表本身
    * */
    var orReg = /x|y/; //只要字符串中出现x或者y就可以
    console.log(orReg.test('zhufengpeixun'));
    var reg = /18|19/;


    //验证是否是有效数字的正则
    //   -  +3  3   3.5   30.555  3.0
    //(+或者-)可以在(开头部分^)(出现一次或者不出现?),  (\.\d+)?这个处理的是小数部分要么一起出现要么一起消失
    //(\d|[1-9]\d+)这个部分是整数部分： 整数部分可以是单位数， 也可以是多位数如果是多位数那么多位数的第一位不能是0那就是[1-9],多位数从第二位开始我只要求是个数字就可以
    var reg = /^[+-]?(\d|[1-9]\d+)(\.\d+)?$/; //04 [1-9]\d+ 这种
    // ^[+-]?  这是前面正号或者负号可以出现可以不出现
    //(\d|[1-9]\d+) 这是整数部分，整数部分：分为单位数和多位数  “|”前面的\d是匹配单位数的  “|”后面的[1-9]\d+是匹配多位数的，如果是多位数不以0开头[1-9],从第二位到第n位可以是至少一个\d了
    //(\.\d+) 小数部分  小数点需要转义,小数点后面的数字可以出现\d多次

    //邮箱  tianxiallen@163.com  tianxi@cmcm.com  tianxi@netqin.com  121170784@qq.com   _tianxi@zhufeng.com.cn企业邮箱  .org  .hk  .jp   qiancheng@sina.com.cn

    var reg = /^[\w.-]+@([a-z]|[0-9]){2,}(\.[a-z]{2,4}){1,2}$/;


    /*
    * 字面量的方式和实例创建方式的区别
    *       1 如果需要用\d等特殊意义的元字符在实例创建的时候需要转义
    *       2 实例创建的时候第一个参数是正则字符串，第二个参数是修饰符也是一个字符串
    *       3
    * */
    var regZi = /\d/g;
    var regShi = new RegExp('\\d','g'); //实例创建的时候参数是一个字符串,用实例创建的时候特殊意义的元字符都代表了本身,需要用\去转义
    console.log(regZi.test('9'));
    console.log(regShi.test('0'));
    var name = 'zhufeng';
    var reg = /name/; //这是代表的name这个字符串还是name变量呢？ 字面量里面不能用变量
    var reg = new RegExp(name+'j');  //用实例创建的时候可以使用变量并且可以拼接字符串
    var ary = ['a','b','c'];
    for(var i=0; i<ary.length; i++){
        var reg = new RegExp(ary[i]+'\\d');  //这个正则在每次循环的时候都代表不同的正则
    }
    console.log(reg.test('zhufengj'));

    //match(字符串) exec replace  ?的用法   小括号分组和分组的引用 \1 \2  lastIndex  RegExp.$1 $1-$9

    //正则：正向预查 和 负向预查  不建议大家看









</script>